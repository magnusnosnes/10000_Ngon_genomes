---
knit: (function(input_file, encoding) {
  out_dir <- '.';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'global_analysis.html'))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


```{r, include=FALSE}
#Load required packages and local variables
library(ape)
library(LineageHomology)
library(skygrowth)
library(grid)
library(scales) #Make more axis ticks.
library(gridExtra)
library(ggplot2)
library(phylodyn)
library(pbapply)
library(ggtree)

#Notes:
#Time consuming sections are commented out. The results are saved and loaded on new runs instead of rerunning every time. 
#Had to install an older version of RcppArmadillo to get the script running
#"install.packages("https://cran.r-project.org/src/contrib/Archive/RcppArmadillo/RcppArmadillo_0.9.900.3.0.tar.gz", repos=NULL, type="source")"

#Setup paths
path_main = "~/Dropbox/10000_Lovers/Phylogeography"
path_data = "~/Dropbox/10000_Lovers/01_LineageHomology/11_saved_data/"
path_results = "~/Dropbox/10000_Lovers/01_LineageHomology/12_saved_results/"

source("~/Dropbox/10000_Lovers/01_LineageHomology/sourcefunctions/environment_variables_without_absolute_paths.R")

```

```{r warning=FALSE, include=FALSE}
library(phytools)
library(skygrowth)
library(plotly)

## Better way of doing this is by using a interactive phylogeny app

pdf("~/Dropbox/Testing_folder/tree.pdf",width = 30,height = 30)
plot(tree, show.tip.label = F)
nodelabels(cex =0.25)
dev.off()

#nts: can run the app to find the appropriate node number.
mtrSubtreeNode = 9779
timeShift = 1750+nodeheight(tree, node=9779) #Root time for the subclade. 

#Extract and plot trees
mtrSubtree = extract.clade(tree, node = 9779)
plot(mtrSubtree,show.tip.label = F)
remainder_tree = drop.tip(tree, tip = mtrSubtree$tip.label)
plot(remainder_tree, show.tip.label = F)

#Checking that tree has been split correctly.
length(tree$tip.label); length(remainder_tree$tip.label); length(mtrSubtree$tip.label) 
```

# Global metadata effective population size analysis

we want to describe large clades that differ in some metadata with respect to the rest of the tree. 
First we look at the distribution of mosaic  variants of  the genes mtr and penA, minimum inhibitory concentration (MIC) (categorised into levels high and low) levels,  and  sex  distribution, 

```{r,include=F}
#Define skygrowth with shifted time
custom_skygrowth_plot <- function( fit,shift_time=NA,ggplot=TRUE, logy=TRUE,xname=NA,xlimits=NA){
  ne <- fit$ne
  fit$time<-fit$time+shift_time
  pldf <- data.frame( t = fit$time,  nemed = ne, nelb = fit$ne_ci[,1], neub = fit$ne_ci[,3] )
  pl <- ggplot2::ggplot( pldf, ggplot2::aes_( x = ~ t, y = ~ nemed)) + ggplot2::geom_line()+ ggplot2::ylab('Effective population size') +xlab("Time")+theme_bw()
  pl <- pl + ggplot2::geom_ribbon( ggplot2::aes_( ymin = ~ nelb, ymax = ~ neub), fill = 'blue', alpha = .2)
  if(logy==T){
    pl <- pl + ggplot2::scale_y_log10()  
  }
  if(is.na(xlimits)==F){
    ind_select = which(fit$time>=xlimits)
    fit$ne_ci[ind_select,]; ylims = range(fit$ne_ci[ind_select,])
    pl<-pl+lims(x=c(xlimits,NA),y=ylims)
  }
  return(pl)
}

```


```{r warning=FALSE, include=F, fig.height=15, fig.width=15, echo=F}

#   ____________________________________________________________________________
#   Skygrowth on important nodes                                            ####


#sgRemainder = skygrowth.map(remainder_tree)

#sgSubtree = skygrowth.map(mtrSubtree)


#custom_skygrowth_plot(sgSubtree,shift_time = timeShift,logy=T)

#custom_skygrowth_plot(sgRemainder,shift_time = 1750,logy=T)

#Need an app 
#construct consise data
#NB: GGtree needs an "id" for tree tip labels
#Example: #library(TDbook); head(TDbook::df_info)

metaDataTimeTree = data.frame("id"=tree$tip.label,
                              "penaMosaic"= penA$mosaic[match_tiplabels_penA],
                              "penaMicCategory"= penA$ESC_MIC_category[match_tiplabels_penA],
                              "mtrMosaic"=mtr$mtrD_mosaic[match_tiplabels_mtrD],
                              "mtrindels"=mtr$mtrR_indels[match_tiplabels_mtrD],
                              "Sex"=sample_data$Sex[match_tiplabels])



#Test on node 11738, alt 11775
#Check structure of metadata
#head(metaDataTimeTree)
#length(match_tiplabels_penA)
#penA$ESC_MIC_category



#   ____________________________________________________________________________
#   Test section:                                                          ####


# testTree = extract.clade(tree, node = 11738)
# testData = metaDataTimeTree[which(metaDataTimeTree$id%in%testTree$tip.label),]
# 
# 
# p = ggtree(testTree)
# str(testData); testData2 = testData[,2:6]; rownames(testData2)=testData$id
# p2 = gheatmap(p,testData2, width=0.3,
#        colnames=FALSE, legend_title="Data")+scale_x_ggtree() +
#    scale_y_continuous(expand=c(0, 0.3))+scale_fill_viridis_d(option="D", name="discrete\nvalue")
# p2
# 
# ggplotly(p2) %>% partial_bundle()

#on full tree
# p=ggtree(tree)
# str(metaDataTimeTree); metaDataTimeTree2 = metaDataTimeTree[,2:6]; rownames(metaDataTimeTree2)=metaDataTimeTree$id
# par(mar=c(0.3,0.3,0.3,0.3))
# g2 = gheatmap(p,metaDataTimeTree2, width=0.3,
#        colnames=F, legend_title="Data")
# g2
# ggplotly(g2)

#   ____________________________________________________________________________
#   Functional                                                              ####
library(ggforce)
library(ggnewscale)
library(RColorBrewer)
p = ggtree(tree, mrsd="2019-08-01")
metdat <- p$data %>%
  dplyr::inner_join(metaDataTimeTree, c('label' = 'id')) #Matches the column of id and tree labels.
metdat$dummy_bar_value = as.numeric(rep(1, nrow(metdat)))

df_bar = data.frame(id=tree$tip.label, dummy_bar_value=rep(1, length(tree$tip.label)))

p1 = p %<+% metaDataTimeTree
cols =  c(brewer.pal(12,"Paired")[-12],"#FFFFFF")

p2 = p1+geom_facet(panel = "mtrMosaic", data =df_bar, geom = geom_col, 
                aes(x = dummy_bar_value,
                fill = mtrMosaic), orientation = 'y', width = 1)+labs(fill = "Metadata")+
  new_scale_color()+
  geom_facet(panel = "penA MIC category", data =df_bar, geom = geom_col, 
                aes(x = dummy_bar_value, fill = penaMicCategory
                ), orientation = 'y', width =1)+
  new_scale_color()+
   geom_facet(panel = "penAMosaic", data =df_bar, geom = geom_col,
                 aes(x = dummy_bar_value, fill = penaMosaic
                 ), orientation = 'y', width =1)+
  new_scale_color()+
   geom_facet(panel = "Sex", data =df_bar, geom = geom_col,
                 aes(x = dummy_bar_value, fill = Sex
                 ), orientation = 'y', width =1)+theme_tree2()+theme(legend.position="bottom")+scale_fill_manual(breaks=c("non-mosaic","semi-mosaic","high","low","mosaic","mosaic1","mosaic2","mosaic3","mosaic4","F","M","nd"),values=cols)#scale_fill_brewer(palette="Paired")


p3=  p1+geom_facet(panel = "mtrMosaic", data =df_bar, geom = geom_col, 
                aes(x = dummy_bar_value,
                fill = mtrMosaic), orientation = 'y', width = 1)+theme(legend.position="bottom")+labs(fill = "Metadata")+
  geom_facet(panel = "penA MIC category", data =df_bar, geom = geom_col, 
                aes(x = dummy_bar_value, fill = penaMicCategory
                ), orientation = 'y', width = 1)+
   geom_facet(panel = "penAMosaic", data =df_bar, geom = geom_col,
                 aes(x = dummy_bar_value, fill = penaMosaic
                 ), orientation = 'y', width = 1)+
   geom_facet(panel = "Sex", data =df_bar, geom = geom_col,
                 aes(x = dummy_bar_value, fill = Sex
                 ), orientation = 'y', width = 1)+theme_tree2()+scale_fill_manual(breaks=c("non-mosaic","semi-mosaic","high","low","mosaic","mosaic1","mosaic2","mosaic3","mosaic4","F","M","nd"),values=cols)#scale_fill_brewer(palette="Paired")



```

### Tree with metadata

The fully annotated tree shows that most of the mosaic variant of mtr clusters in distict part of the tree. 
High HIC categories also clusters in some sections of the tree. 
The sex distribution does not have major evident clusters when we look at the tree as a whole, but in smaller sections of the tree.


```{r, include=T, echo=F,  warning=F,fig.height=15, fig.width=15}
#Adjust the facet_widths. 
p2 = facet_widths(p2, c(Tree=12))
p2
```

## An interactive version of the plot can be explored below

```{r,  include=T, echo=F, warning=F, fig.height=10, fig.width=10}
#Interactive plot
ggplotly(p3) %>% layout(legend=list(x=0, 
                                 xanchor='left',
                                 yanchor='bottom',
                                 orientation='h'))    %>% partial_bundle()

```

### Clades

The pictures below shows subtrees (see interactive plot) we deem important and for which we will estimate the effective population size dynamics.

## [Subtree 1]()

## [Subtree 2]()

## [Subtree 3]()

```{r,  include=F, echo=F, warning=F, fig.height=10, fig.width=10}

#   ____________________________________________________________________________
#   Testing section below                                                   ####


# LOAD LIBS ---------------------------------------------------------------
# library(ape)
# library(ggtree)
# library(plotly)
# CREATE A TREE -------------------------------------------------------------
# n_samples <- 20
# n_grp <- 4
# tree <- ape::rtree(n = n_samples)
# # CREATE SOME METADATA ----------------------------------------------------
# id <- tree$tip.label
# set.seed(42)
# grp <- sample(LETTERS[1:n_grp], size = n_samples, replace = T)
# dat <- tibble::tibble(id = id,
#                       grp = grp)
# # PLOT THE TREE -----------------------------------------------------------
# p1 <- ggtree(tree)
# metat <- p1$data %>%
#   dplyr::inner_join(dat, c('label' = 'id'))
# p2 <- p1 +
#   geom_point(data = metat,
#              aes(x = x,
#                  y = y,
#                  colour = grp,
#                  label = id))
# plotly::ggplotly(p2)

# +
#     theme_tree2(legend.position=c(.05, .85))


#Test
## load `tree_nwk`, `df_info`, `df_alleles`, and `df_bar_data` from 'TDbook'
# tree <- tree_nwk
# df_bar_data$dummy_bar_value=rep(1, length(df_bar_data$dummy_bar_value)) #Remove to get back real data
# ## visualize the tree 
# test3 <- ggtree(tree) 
# 
# ## attach the sampling information data set 
# ## and add symbols colored by location
# test3 <- test3 %<+% df_info
# 
# ## visualize SNP and Trait data using dot and bar charts,
# ## and align them based on tree structure
# t3 = test3 +
#     geom_facet(panel = "Trait", data = df_bar_data, geom = geom_col, 
#                 aes(x = dummy_bar_value, color = location, 
#                 fill = location), orientation = 'y', width = .6) 
# t3
# +
#     theme_tree2(legend.position=c(.05, .85))

# +
# geom_facet(panel = "Trait2", data = df_bar_data, geom = geom_col, 
#                 aes(x = dummy_bar_value, color = location, 
#                 fill = location), orientation = 'y', width = .6)
  
# t3
# #Make it interactive
# ggplotly(t3)


#   ____________________________________________________________________________
#   Test station 2                                                          ####



# myTest = ggtree(testTree)
# metdat <- myTest$data %>%
#   dplyr::inner_join(testData, c('label' = 'id')) #Matches the column of id and tree labels.
# metdat$dummy_bar_value = as.numeric(rep(1, nrow(metdat)))
# metdat=as.data.frame(metdat)
# 
# myTest = myTest %<+% metdat
# 
# df_bar_data2 = data.frame(id=testTree$tip.label, dummy_bar_value=rep(1, length(testTree$tip.label)))
# df_bar_data2
# head(df_bar_data2)
# head(df_bar_data)
# #Compared with mine:
# myTest = myTest+geom_facet(panel = "Trait", data =df_bar_data2, geom = geom_col,
#                 aes(x = df_bar_data2$dummy_bar_value, color = mtrindels,
#                 fill = mtrindels), orientation = 'y', width = 0.8)
# 
# myTest= facet_widths(myTest, c(Tree=5))
# myTest
#   ____________________________________________________________________________
#   This was too slow                                                      ####

# myTest = ggtree(testTree) 
# metdat <- myTest$data %>%
#   dplyr::inner_join(testData, c('label' = 'id')) #Matches the column of id and tree labels.
# metdat$dummy_bar_value = as.integer(rep(1, nrow(metdat)))
# pp = myTest+geom_tippoint(data=metdat,aes(x=x,y=y,colour=penaMosaic))#+geom_facet(panel="Test",data = testData, geom=geom_col,aes(color=penaMosaic))
# 
# pp+geom_facet(panel = "Trait", data =metdat, geom = geom_col, 
#                 aes(x = dummy_bar_value, color = mtrMosaic, 
#                 fill = mtrMosaic), orientation = 'y', width = .6)
# #geom_facet(data=metdat, panel="Test",geom=geom_col,aes(x=x,y=y,colour=penAMicCategory))
# gheatmap(myTest,metdat)
# ggplotly(pp)


```

